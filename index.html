<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genetic Mutations Tree</title>
    <style>
        /* Basic styles for the tree */
        .node {
            cursor: pointer;
        }
        .node:hover {
            stroke: #2ecc71;
            stroke-width: 2px;
        }
        .label {
            font-size: 12px;
        }
        svg {
            font: 12px sans-serif;
        }
        text {
            pointer-events: none;
        }
        .link {
            stroke: #3498db;
            stroke-width: 2px;
        }
        circle {
            fill: #e74c3c;
            stroke: #c0392b;
            stroke-width: 2px;
        }
        /* Container for the SVG */
        #tree {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide overflow to prevent content from leaving bounds */
        }
    </style>
</head>
<body>
    <div id="tree"></div>

    <!-- Load D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            // Load CSV data from Google Sheets
            Papa.parse('https://docs.google.com/spreadsheets/d/e/2PACX-1vRnDqmeMrSFgOBL5MHbulxNw7F9PO4PZBFXtBqEyPmiljTZWQCTwakxKiRneckhvknl-jpvOeR7PuJT/pub?output=csv', {
                download: true,
                header: true,
                complete: function(results) {
                    const data = results.data;
                    const treeData = buildTreeData(data);
                    drawTree(treeData);
                },
                error: function(error) {
                    console.error('Error loading CSV data:', error);
                }
            });

            function buildTreeData(data) {
                // Create a hierarchical tree structure based on the data
                let tree = { name: 'j', children: [] };
                let nodes = {};
                nodes['j'] = tree;

                data.forEach(row => {
                    if (!row['mutationInfo']) return; // Skip rows without mutations
                    const mutations = row['mutationInfo'].split('>');
                    let currentNode = nodes['j'];

                    mutations.forEach(mutation => {
                        if (!nodes[mutation]) {
                            nodes[mutation] = { name: mutation, children: [], samples: [] };
                            currentNode.children.push(nodes[mutation]);
                        }
                        currentNode = nodes[mutation];
                    });
                    currentNode.samples.push({ name: row['personInfo'], location: row['locationInfo'] });
                });

                return tree;
            }

            function drawTree(treeData) {
                const width = 1200;
                const height = 800;
                const margin = 40; // Margin to prevent text overlap

                const svg = d3.select('#tree').append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${margin},${margin})`);

                const root = d3.hierarchy(treeData);
                const treeLayout = d3.tree().size([width - 2 * margin, height - 2 * margin]);
                treeLayout(root);

                // Links
                svg.selectAll('line.link')
                    .data(root.descendants().slice(1))
                    .enter().append('line')
                    .attr('class', 'link')
                    .attr('x1', d => d.x)
                    .attr('y1', d => d.y)
                    .attr('x2', d => d.parent.x)
                    .attr('y2', d => d.parent.y);

                // Nodes
                const node = svg.selectAll('g.node')
                    .data(root.descendants())
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x},${d.y})`);

                node.append('circle')
                    .attr('r', 6);

                node.append('text')
                    .attr('dy', 3)
                    .attr('x', d => d.children ? -12 : 12)
                    .style('text-anchor', d => d.children ? 'end' : 'start')
                    .style('fill', '#34495e')
                    .style('font-size', '10px')
                    .text(d => d.data.name)
                    .call(wrap, 100); // Wrap text if it exceeds a certain width

                // Add samples information
                node.append('title')
                    .text(d => {
                        if (!d.data.samples) return '';
                        return d.data.samples.map(s => `${s.name} (${s.location})`).join('\n');
                    });

                // Zoom and pan settings
                const zoom = d3.zoom()
                    .scaleExtent([0.5, 2]) // Min and max zoom levels
                    .translateExtent([[-width, -height], [2 * width, 2 * height]]) // Bounds for panning
                    .on("zoom", (event) => {
                        svg.attr("transform", event.transform);
                    });

                d3.select("svg").call(zoom);

                // Function to wrap text
                function wrap(text, width) {
                    text.each(function() {
                        const text = d3.select(this);
                        const words = text.text().split(/\s+/).reverse();
                        let word;
                        let line = [];
                        let lineNumber = 0;
                        let lineHeight = 1.1; // ems
                        let y = text.attr("y");
                        let dy = parseFloat(text.attr("dy")) || 0;
                        let tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", dy + "em");
                        
                        while (word = words.pop()) {
                            line.push(word);
                            tspan.text(line.join(" "));
                            if (tspan.node().getComputedTextLength() > width) {
                                line.pop();
                                tspan.text(line.join(" "));
                                line = [word];
                                tspan = text.append("tspan").attr("x", 0).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                            }
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>
